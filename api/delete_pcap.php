<?php
/**
 * Delete PCAP file
 */

require_once __DIR__ . '/../config/config.php';

header('Content-Type: application/json');

if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
    http_response_code(405);
    echo json_encode(['error' => 'Method not allowed']);
    exit;
}

$input = json_decode(file_get_contents('php://input'), true);
$filename = $input['filename'] ?? null;

if (!$filename) {
    http_response_code(400);
    echo json_encode(['error' => 'Filename required']);
    exit;
}

// Security: prevent directory traversal
$filename = basename($filename);

// Validate filename format: pcap_<hex>.<hex>.json
// This matches the format generated by uniqid() in upload_pcap.php
if (!preg_match('/^pcap_[a-f0-9_]+\.[a-f0-9]+\.json$/i', $filename)) {
    http_response_code(400);
    echo json_encode(['error' => 'Invalid filename format']);
    exit;
}

// Additional security: ensure it's actually a JSON file
if (pathinfo($filename, PATHINFO_EXTENSION) !== 'json') {
    http_response_code(400);
    echo json_encode(['error' => 'Invalid file type']);
    exit;
}

$jsonPath = PROCESSED_PATH . '/' . $filename;
$deleted = [];
$errors = [];

// Check if JSON file exists
if (!file_exists($jsonPath)) {
    http_response_code(404);
    echo json_encode(['error' => 'Processed file not found']);
    exit;
}

// Get PCAP filename from JSON if available
$data = json_decode(file_get_contents($jsonPath), true);
$pcapFilename = $data['pcap_filename'] ?? null;

// If pcap_filename is not in JSON, try to derive it from the JSON filename
// JSON filename format: pcap_<hex>.<hex>.json
// PCAP filename format: pcap_<hex>.<hex>.pcap or pcap_<hex>.<hex>.pcapng
if (!$pcapFilename) {
    // Try common extensions
    $baseName = pathinfo($filename, PATHINFO_FILENAME); // Gets pcap_<hex>.<hex>
    $possibleExtensions = ['pcap', 'pcapng'];
    
    foreach ($possibleExtensions as $ext) {
        $possiblePcapPath = UPLOAD_PATH . '/' . $baseName . '.' . $ext;
        if (file_exists($possiblePcapPath)) {
            $pcapFilename = $baseName . '.' . $ext;
            break;
        }
    }
}

// Delete JSON file (processed file) first
if (unlink($jsonPath)) {
    $deleted[] = 'processed';
} else {
    $errors[] = 'Failed to delete processed JSON file';
}

// Delete original PCAP file if we found it
if ($pcapFilename) {
    $pcapPath = UPLOAD_PATH . '/' . basename($pcapFilename);
    if (file_exists($pcapPath)) {
        if (unlink($pcapPath)) {
            $deleted[] = 'pcap';
        } else {
            $errors[] = 'Failed to delete original PCAP file';
        }
    }
} else {
    // Try to find and delete any PCAP file with the same base name
    $baseName = pathinfo($filename, PATHINFO_FILENAME);
    $possibleExtensions = ['pcap', 'pcapng'];
    
    foreach ($possibleExtensions as $ext) {
        $possiblePcapPath = UPLOAD_PATH . '/' . $baseName . '.' . $ext;
        if (file_exists($possiblePcapPath)) {
            if (unlink($possiblePcapPath)) {
                $deleted[] = 'pcap';
                break;
            }
        }
    }
}

// Also check if this file is currently loaded in playback state and clear it
$playbackStateFile = PLAYBACK_STATE_FILE;
if (file_exists($playbackStateFile)) {
    $state = json_decode(file_get_contents($playbackStateFile), true) ?? [];
    if (isset($state['current_file']) && $state['current_file'] === $filename) {
        // Clear the current file from playback state
        $state['current_file'] = null;
        $state['current_time'] = 0;
        $state['is_playing'] = false;
        file_put_contents($playbackStateFile, json_encode($state, JSON_PRETTY_PRINT));
        $deleted[] = 'playback_state';
    }
}

if (empty($deleted)) {
    http_response_code(404);
    echo json_encode(['error' => 'No files found to delete']);
    exit;
}

$response = [
    'success' => true,
    'filename' => $filename,
    'deleted' => $deleted
];

if (!empty($errors)) {
    $response['warnings'] = $errors;
}

echo json_encode($response);
